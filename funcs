#!/bin/bash
# vim: syntax=sh tw=200:

# Some custom functions, and also the aliases for make them shorten when using.
# Because the functions is self-defined, their aliases should be kept here, not
# in the ~/.aliases file.

# Load antidote and run antidote commands (update/install/etc)
# Usage: antidote-load [command] [args...]
#   antidote-load update     # Update all plugins
#   antidote-load install    # Install plugins from plugins.txt
#   antidote-load list       # List installed plugins
antidote-load() {
  local antidote_dir="${ZDOTDIR:-$HOME}/.antidote"

  # Clone antidote if missing
  if [[ ! -d "$antidote_dir" ]]; then
    echo "Installing antidote..."
    git clone --depth=1 https://github.com/mattmc3/antidote.git "$antidote_dir"
  fi

  # Source antidote
  source "$antidote_dir/antidote.zsh"

  # Run command if provided
  if [[ $# -gt 0 ]]; then
    antidote "$@"
  else
    echo "antidote loaded. Available commands: update, install, list, bundle, etc."
  fi
}

# Regenerate plugins.zsh from plugins.txt (forces rebuild)
antidote-regen() {
  antidote-load
  local zsh_plugins="${DOTFILES}/plugins.zsh"
  echo "Regenerating $zsh_plugins..."
  antidote bundle <"${zsh_plugins:r}.txt" >| "$zsh_plugins"
  echo "Done. Restart shell or run: source $zsh_plugins"
}

# Start git fsmonitor daemon for current repo (speeds up git status/diff)
# Usage: git-fsm [start|stop|status]
git-fsm() {
  local action="${1:-start}"
  case "$action" in
    start)
      git fsmonitor--daemon start 2>/dev/null && echo "fsmonitor daemon started" || echo "already running or not a git repo"
      ;;
    stop)
      git fsmonitor--daemon stop 2>/dev/null && echo "fsmonitor daemon stopped" || echo "not running"
      ;;
    status)
      git fsmonitor--daemon status 2>&1
      ;;
    *)
      echo "Usage: git-fsm [start|stop|status]"
      ;;
  esac
}

# Remove entries from zsh history interactively using fzf
# Usage: hist-del        # Select entries with fzf to delete
#        hist-del -1     # Delete last entry
#        hist-del "pattern"  # Delete entries matching pattern
hist-del() {
  local histfile="${HISTFILE:-$HOME/.zsh_history}"

  if [[ "$1" == "-1" ]]; then
    # Delete last entry
    fc -W
    sed -i '' '$d' "$histfile"
    fc -R
    echo "Deleted last history entry"
  elif [[ -n "$1" ]]; then
    # Delete by pattern
    fc -W
    local count=$(grep -c "$1" "$histfile")
    sed -i '' "/$1/d" "$histfile"
    fc -R
    echo "Deleted $count entries matching: $1"
  else
    # Interactive fzf selection (multi-select with Tab)
    fc -W
    local selections=$(fc -l 1 | fzf --multi --tac --no-sort \
      --header="Tab to select multiple, Enter to delete" \
      --preview="echo {}" --preview-window=up:1)

    [[ -z "$selections" ]] && echo "Nothing selected" && return 0

    # Extract line numbers and delete from newest to oldest
    local nums=$(echo "$selections" | awk '{print $1}' | sort -rn)
    local count=0
    for n in ${(f)nums}; do
      sed -i '' "${n}d" "$histfile"
      ((count++))
    done
    fc -R
    echo "Deleted $count history entries"
  fi
}

# Open the ebook from command line using zathura, this also make za an alias to
# zathura.
# Usage:
#   za [file_name]
# If file_name is not provided, simply open zathura.
za() {
  if [ $# -eq 0 ]; then
    (zathura &)
  else
    (zathura "$1" &)
  fi
}

# Add, commit and push in single call. For lazy people.
# Shouldn't use this on serious project. It's would pollute your git history!
lazygit() {
  if [ $# -eq 0 ]; then # Check for commit message
    echo "Need a commit message"
    return 1
  fi
  git add .
  git commit -a -m "$*"
  git push
}

alias lg="lazygit" # And even more lazy

fancy_echo() {
  echo "========================================"
  echo "- $*"
  echo "========================================"
}

# Update software
update_software() {

  #  Ubuntu
  if command -v apt-get >/dev/null 2>&1; then
    fancy_echo "Update software for Ubuntu"
    sudo apt update
    sudo apt full-upgrade -y
    sudo apt autoremove -y
  fi

  #  Centos
  if command -v yum >/dev/null 2>&1; then
    fancy_echo "Update software for Centos"
    sudo yum update -y
  fi

  if command -v brew >/dev/null 2>&1; then
    fancy_echo "Update software installed by homebrew"
    brew update
    brew upgrade
  fi

  #  Vim
  fancy_echo "Vim plugins"
  # Execute vim-plug upgrade, then update all plugins
  vim -c "PlugUpgrade" -c "qa!"
  vim -c "PlugUpdate" -c "qa!"
  vim -c "UpdateRemotePlugins" -c "qa!"

  # ensure zsh/kitty known about xterm-256color-italic
  tic "$DOTFILES/xterm-256color-italic.terminfo"

  # update zsh plugins
  antidote update

  # update mise tools and plugins
  if command -v mise >/dev/null 2>&1; then
    mise self-update -y
    mise up -l --cd $TMPDIR
  fi
}

dkpg() {
  if command -v podman >/dev/null 2>&1; then
    cmd=podman
  else
    cmd=docker
  fi

  echo "> Starting postgres container using $cmd"
  $cmd run --rm -d --name dkpg -e POSTGRES_PASSWORD=123 -p 5432:5432 postgres
}

dkmy() {
  if command -v podman >/dev/null 2>&1; then
    cmd=podman
  else
    cmd=docker
  fi

  echo "> Starting mysql container using $cmd"
  $cmd run --rm -d --name dkmy -e MYSQL_ROOT_PASSWORD=123 -p 3306:3306 mysql
}

dkrd() {
  if command -v podman >/dev/null 2>&1; then
    cmd=podman
  else
    cmd=docker
  fi

  echo "> Starting redis container using $cmd"
  $cmd run --rm -d --name dkrd -p 6379:6379 redis
}

dkmg() {
  if command -v podman >/dev/null 2>&1; then
    cmd=podman
  else
    cmd=docker
  fi

  echo "> Starting mongo container using $cmd"
  $cmd run --rm -d --name dkmg -p 27017:27017 mongo
}

one_of() {
  list=("$@")
  one=${list[$RANDOM % ${#list[@]}]}
  echo "$one"
}

local_todo() {
  repo=$(git rev-parse --show-toplevel 2>/dev/null)
  if [[ -z $repo ]]; then
    echo "not a git repo"
    return
  fi

  mkdir -p "$repo"/.dump
  vim "$repo"/.dump/todo.md
}

# https://yazi-rs.github.io/docs/quick-start/#shell-wrapper
yazi_cd() {
  tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    builtin cd -- "$cwd" || exit
  fi
  rm -f -- "$tmp"
}

function killport() {
    local port=""
    local force_yes=false

    # Parse arguments in any order
    for arg in "$@"; do
        if [[ "$arg" == "-y" ]]; then
            force_yes=true
        elif [[ "$arg" =~ ^[0-9]+$ ]]; then
            port="$arg"
        fi
    done

    # Validate port argument
    if [[ -z "$port" ]]; then
        echo "Usage: killport [port] [-y] or killport [-y] [port]"
        return 1
    fi

    # Find processes using the port
    pids=$(lsof -i ":$port" -t 2>/dev/null)

    if [[ -z "$pids" ]]; then
        echo "No process found listening on port $port"
        return 1
    fi

    # Show all processes using this port
    echo "Found process(es) on port $port:"
    while IFS= read -r pid; do
        process_info=$(ps -p "$pid" -o pid,user,command | tail -n 1)
        echo "$process_info"
    done <<< "$pids"

    if [[ "$force_yes" == true ]]; then
        echo "Killing process(es)..."
        while IFS= read -r pid; do
            kill -9 "$pid"
        done <<< "$pids"
        echo "Process(es) killed"
    else
        echo -n "Do you want to kill these process(es)? (y/N) "
        read -r answer
        if [[ $answer =~ ^[Yy]$ ]]; then
            while IFS= read -r pid; do
                kill -9 "$pid"
            done <<< "$pids"
            echo "Process(es) killed"
        else
            echo "Operation cancelled"
        fi
    fi
}

# zoxide restricted to git repo (or current directory)
# Falls back to fd + fzf if zoxide finds no match
j() {
  local result
  local root

  # Try to get git root, fallback to PWD
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    root=$(git rev-parse --show-toplevel)
  else
    root="$PWD"
  fi

  # Try zoxide first (only if query provided)
  if [[ -n "$*" ]]; then
    result=$(zoxide query --list "$@" | awk -v prefix="$root" 'index($0, prefix) == 1' | head -n 1)
    if [[ -n "$result" ]]; then
      cd "$result"
      return 0
    fi
  fi

  # Fallback: use fd to find directories
  local query="${*}"
  local matches
  if [[ -n "$query" ]]; then
    matches=$(cd "$root" && fd --type d --hidden --exclude .git --glob "*${query}*")
  else
    matches=$(cd "$root" && fd --type d --hidden --exclude .git)
  fi

  local count=$(echo "$matches" | grep -c '^')

  # No matches found
  if [[ $count -eq 0 ]]; then
    echo "No matching directories found"
    return 1
  fi

  # Single match - jump directly
  if [[ $count -eq 1 ]]; then
    cd "$root/$matches"
    return 0
  fi

  # Multiple matches - use fzf
  result=$(echo "$matches" | fzf --height 40% --reverse \
    --preview "ls -A --color=always '$root/{}'" \
    --preview-window=right:50%:wrap)
  if [[ -z "$result" ]]; then
    echo "No directory selected"
    return 1
  fi

  cd "$root/$result"
}


