#!/bin/bash
# gwt-prune - Prune git worktrees whose remote branches are gone
#
# This script checks all worktrees and removes them if:
# 1. Branch was pushed before (has upstream tracking)
# 2. Remote branch is now gone (PR merged/deleted)
# 3. Local branch has no unique commits compared to main (fully merged)
#    - Detects squash-merged PRs (code diff is empty)
#    - Detects rebased branches (patch-ids match commits in main)
#
# Local-only branches (never pushed) are also removed if all their commits
# are merged/rebased onto the default branch. Local branches with unique
# commits are kept.
#
# Usage: gwt-prune [--dry-run] [--force]
#   --dry-run  Show what would be removed without actually removing
#   --force    Remove worktrees even if they have unmerged commits

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

DRY_RUN=false
FORCE=false

# Parse arguments
for arg in "$@"; do
    case $arg in
        --dry-run)
            DRY_RUN=true
            ;;
        --force)
            FORCE=true
            ;;
        -h|--help)
            echo "Usage: $0 [--dry-run] [--force]"
            echo "  --dry-run  Show what would be removed without actually removing"
            echo "  --force    Remove worktrees even if they have unmerged commits"
            exit 0
            ;;
    esac
done

# Get the main worktree (bare repo or main checkout)
MAIN_WORKTREE=$(git worktree list --porcelain | grep -A2 "^worktree " | head -1 | sed 's/worktree //')
MAIN_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")

# Fetch and prune remote tracking branches
echo -e "${BLUE}Fetching remote refs...${NC}"
git fetch --prune --all 2>/dev/null || true
echo ""

# Get list of worktrees (skip the main one)
worktrees_to_check=()
while IFS= read -r line; do
    worktree_path=$(echo "$line" | awk '{print $1}')
    branch=$(echo "$line" | sed -n 's/.*\[\(.*\)\].*/\1/p')

    # Skip main worktree and main branch
    if [[ "$worktree_path" == "$MAIN_WORKTREE" ]] || [[ "$branch" == "$MAIN_BRANCH" ]]; then
        continue
    fi

    worktrees_to_check+=("$worktree_path|$branch")
done < <(git worktree list)

if [[ ${#worktrees_to_check[@]} -eq 0 ]]; then
    echo -e "${GREEN}No worktrees to check (only main worktree exists).${NC}"
    exit 0
fi

removed_count=0
skipped_count=0
kept_count=0

for entry in "${worktrees_to_check[@]}"; do
    worktree_path="${entry%|*}"
    branch="${entry#*|}"

    # Check if branch has upstream tracking configured (was ever pushed)
    has_tracking=$(git config "branch.$branch.remote" 2>/dev/null || echo "")

    # Check if remote branch exists
    remote_exists=true
    if ! git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
        remote_exists=false
    fi

    # Check if branch has unmerged commits compared to main
    unmerged_commits=$(git log --oneline "origin/$MAIN_BRANCH..$branch" 2>/dev/null | wc -l | tr -d ' ')
    unmerged_subjects=""
    has_unmerged=false
    is_squash_merged=false
    is_rebased=false

    if [[ "$unmerged_commits" -gt 0 ]]; then
        has_unmerged=true
        # Get commit subjects
        unmerged_subjects=$(git log --format="%s" "origin/$MAIN_BRANCH..$branch" 2>/dev/null)
        # Check for squash-merged PRs (code diff is empty)
        code_diff_lines=$(git diff "origin/$MAIN_BRANCH...$branch" 2>/dev/null | wc -l | tr -d ' ')
        [[ "$code_diff_lines" -eq 0 ]] && is_squash_merged=true
        # Check for rebased branches using git cherry (compares patch-ids)
        # If all commits show '-' prefix, they have equivalent patches in main
        if [[ "$is_squash_merged" == false ]]; then
            unique_commits=$(git cherry "origin/$MAIN_BRANCH" "$branch" 2>/dev/null | grep -c '^+') || unique_commits=0
            [[ "$unique_commits" -eq 0 ]] && is_rebased=true
        fi
    fi

    # Check for uncommitted changes in worktree
    has_uncommitted=false
    if [[ -d "$worktree_path" ]]; then
        uncommitted=$(git -C "$worktree_path" status --porcelain 2>/dev/null | wc -l | tr -d ' ')
        [[ "$uncommitted" -gt 0 ]] && has_uncommitted=true
    fi

    # Decide action
    should_remove=false
    reason=""

    if [[ -z "$has_tracking" ]]; then
        # Local-only branch: remove if all commits are in main
        if [[ "$has_uncommitted" == true ]] && [[ "$FORCE" != true ]]; then
            reason="local-only (uncommitted changes)"
        elif [[ "$has_unmerged" == false ]]; then
            should_remove=true
            reason="local-only (merged)"
        elif [[ "$is_squash_merged" == true ]]; then
            should_remove=true
            reason="local-only (squash-merged)"
        elif [[ "$is_rebased" == true ]]; then
            should_remove=true
            reason="local-only (rebased)"
        elif [[ "$FORCE" == true ]]; then
            should_remove=true
            reason="local-only (forced)"
        else
            reason="local-only ($unmerged_commits unique commits)"
        fi
    elif [[ "$remote_exists" == true ]]; then
        reason="remote exists"
    elif [[ "$has_uncommitted" == true ]] && [[ "$FORCE" != true ]]; then
        reason="uncommitted changes"
    elif [[ "$has_unmerged" == false ]]; then
        should_remove=true
        reason="merged"
    elif [[ "$is_squash_merged" == true ]]; then
        should_remove=true
        reason="squash-merged"
    elif [[ "$is_rebased" == true ]]; then
        should_remove=true
        reason="rebased"
    elif [[ "$FORCE" == true ]]; then
        should_remove=true
        reason="forced"
    else
        reason="unmerged ($unmerged_commits commits)"
    fi

    # Output and execute
    if [[ "$should_remove" == true ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            echo -e "${RED}REMOVE${NC}  $branch ${YELLOW}($reason)${NC}"
        else
            echo -e "${RED}REMOVE${NC}  $branch ($reason)"
            git worktree remove "$worktree_path" --force 2>/dev/null || {
                rm -rf "$worktree_path"
                git worktree prune
            }
            git branch -D "$branch" 2>/dev/null || true
        fi
        ((removed_count++))
    elif [[ "$remote_exists" == false ]] && [[ -n "$has_tracking" ]] && [[ "$has_uncommitted" != true ]]; then
        echo -e "${YELLOW}SKIP${NC}    $branch"
        while IFS= read -r subject; do
            echo -e "          ${YELLOW}-${NC} $subject"
        done <<< "$unmerged_subjects"
        ((skipped_count++))
    else
        echo -e "${GREEN}KEEP${NC}    $branch ($reason)"
        ((kept_count++))
    fi
done

# Final cleanup
[[ "$DRY_RUN" == false ]] && git worktree prune 2>/dev/null

# Summary
echo ""
echo -e "Removed: ${RED}$removed_count${NC}  Skipped: ${YELLOW}$skipped_count${NC}  Kept: ${GREEN}$kept_count${NC}"
[[ "$DRY_RUN" == true ]] && echo -e "${YELLOW}(dry-run mode)${NC}"
